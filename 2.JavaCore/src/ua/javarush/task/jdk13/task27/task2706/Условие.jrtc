taskKey="ua.javarush.task.jdk13.task27.task2706"\n\nProducer–consumer

У класі TransferObject розстав виклики методів wait/notify/notifyAll, щоб забезпечити послідовне створення та отримання об&#39;єкта.
У методах run класів ConsumerTask і ProducerTask створи необхідні synchronized блоки.

Виведення програми, на яке ми очікуємо:
...
Put: M
Got: M
Put: N
Got: N
Put: K
Got: K
...
де M, N, K - числа
Метод main не бере участі в тестуванні.

P.S. Завжди намагайся використовувати concurrent колекції замість ручної реалізації wait/notify/notifyAll.
Задачі на кшталт цієї дозволяють краще розібратися в основах роботи багатопотокових застосунків.


Требования:
1.	У класі TransferObject публічний метод get() з типом значення, що повертається, int має бути синхронізований.
2.	У класі TransferObject публічний метод put(int) з типом значения, що повертається, void має бути синхронізований.
3.	Метод get класу TransferObject має чекати на появу value, і повертати його після того, як він з&#39;явиться.
4.	Метод put класу TransferObject повинен чекати, поки value заберуть і оновлять його значення після того, як воно зникне.
5.	Метод get класу TransferObject повинен встановлювати прапор isValuePresent у false та повідомляти інші потоки про ті, що очікують на вивільнення монітора перед повернення значення поля value.
6.	Метод put класу TransferObject повинен встановлювати прапорець isValuePresent у true та повідомляти інші потоки, що очікують на вивільнення монітора після оновлення значення поля value.


