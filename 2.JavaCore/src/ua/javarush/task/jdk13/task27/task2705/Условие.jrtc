taskKey="ua.javarush.task.jdk13.task27.task2705"\n\nПрибираємо deadLock за допомогою використання відкритих викликів

Синхронізовані методи, які викликають всередині себе синхронізовані методи інших класів, призводять до dead-lock-у.
1. Перенесіть синхронізацію з методу до синхронізованого блоку, в якому розмістіть лише необхідні частини коду.
2. Приберіть надлишкову синхронізацію методів.
3. У стеку виклику методів не повинно бути перехресної синхронізації, тобто такого synchronizedMethodAClass().synchronizedMethodBClass().synchronizedMethodAClass()

Цей спосіб позбавлення від дедлоку називається &quot;відкриті виклики&quot;, про них читайте у додатковому матеріалі до лекції.
Метод main не бере участі в тестуванні.


Требования:
1.	Потрібно забезпечити можливість коректної взаємодії об&#39;єктів типу Apartment і RealEstate без виникання взаємних блокувань.
2.	Метод up класу RealEstate потрібно оголосити без модифікатора synchronized.
3.	Метод revalidate класу RealEstate потрібно оголосити без модифікатора synchronized.
4.	Метод revalidate класу Apartment потрібно оголосити без модифікатора synchronized.
5.	Метод revalidate класу RealEstate має містити один synchronized блок.
6.	У synchronized блоці методу revalidate класу RealEstate має міститися виклик методу revalidate на об&#39;єкті apartment з параметром randomValue.


